Still build a native UI... but also option to use just as the Chat/Memory interface, with document 
editing in Obsidian, other markdown editor

faiss? weaviate? for semantic search

Usability issues
- Markdown preview, editor. Do something like VSCode where it shows the source markdown but it is slightly formatted. Or a preview/edit "toggle". But not enough space on the screen for the split view
- When we delete all the threads, we are just left with no threads but still see chat on the right. Sending a message here does nothing. So need to better handle edge cases where no threads/all threads are deleted
- Can't type "shift enter" without submitting the whole chat
- cancel chat messages?

Ideas
- **Branch from here** is nice. But add something where you can also branch from highlighted text?


Multi document editing. Optionally have new document per thread. Or if no document... the document on the left can represent the model's current understanding (KB nodes summary). Maybe too many API calls; after every chat, use thread chat context + K nodes to update the knowledge summary. So the user has a reference of what the "current working state of the conversation" is..

[[json-node-design]]
[[sprint-april]]

- [ ] Summarize threads in 5 words (for thread titles in sidebar)



**Chat/thread vs Nodes**
>Threads are temporary playgrounds. Nodes are the permanent map. Documents are living work artifacts attached to nodes when needed. The real memory is the evolving network of nodes and documents. Context is built dynamically from the best pieces at each moment.

	Concept... the chats themselves are not important. Users won't have to worry about what is in the chat context (like they do with ChatGPT). The important context is saved as nodes, and in the main/thread documents (which you can come back to). User shouldn't stress about when to branch, when to merge threads, etc. Maybe we shouldn't even make it possible to merge threads. Save 1 thread as a node (and/or doc), and then open the other thread and say "bring in ideas x and y, and incorporate what we covered in thread"
	
	But if users aren't supposed to get attached to threads... then the memory/node browsing system should be amazing.
	And some users might still want to work heavily in threads, and keep long-running threads. I should accommodate this as well..
	
	Hmmm this is a core tradeoff. Is it about threads or about knowledge nodes? Or both? Or are threads just a layer/abstraction that sits on top of the nodes? Like it would be just as valid to focus heavier on threading, show knowledge graph of threads, etc. Ooh maybe each thread must correspond to a node? Creating new thread creates new node. If the thread gets fully abandoned, just sever the link from the parent node/thread.
	This accommodates a thread heavy workflow, because you're still building KB in the background.


# Backend Design

```
/data
  /threads
    thread-abc.json
  /nodes
    node-abc.json
  /docs
    doc-abc.json
```

# UI vs Backend responsibilities

## UI (react state)

- **Cache thread list** (`threads[]`) and active thread's **messages** in memory.
- **Cache open document** (`doc`) and all Node metadata you _have already loaded_.
- **Cache minimal node list** (e.g., IDs, titles) once when you enter a project.

Frontend React State handles:
- **Switching threads** instantly (no backend call if already loaded).
- **Typing chat inputs** (instant).
- **Viewing messages** (instant).
- **Editing document** (instant, until you choose to save).

üëâ **Goal**: Never block basic UI interactions waiting on backend. Only call backend when you need real sync or AI help.

## üõ°Ô∏è Backend (FastAPI)

Backend handles:
- **Persisting threads** (create, delete, update metadata)
- **Persisting messages** (after LLM response)
- **Persisting documents** (saving drafts)
- **Creating nodes** (promoting ideas)
- **Building LLM context** dynamically
- **Calling OpenAI** to generate responses
- **Updating knowledge base** (nodes, links, summaries)

Backend _only_ gets called when **new data** must be generated or saved.

| HTTP Method                       | URL                                      | Purpose |
| --------------------------------- | ---------------------------------------- | ------- |
| `GET /api/threads`                | List all threads                         |         |
| `POST /api/threads`               | Create a new thread                      |         |
| `GET /api/threads/{id}`           | Get thread details (metadata + messages) |         |
| `POST /api/threads/{id}/messages` | Add new message(s)                       |         |
| `DELETE /api/threads/{id}`        | Delete a thread                          |         |
| `POST /api/threads/{id}/branch`   | Create a branch from a message index     |         |
| `GET /api/docs/{id}`              | Get document content                     |         |
| `POST /api/docs/{id}`             | Save document content                    |         |
| `GET /api/nodes/{id}`             | Get Node data                            |         |
| `POST /api/nodes`                 | Create new Node from a summary           |         |

## Flow
**New Thread**
Click new thread
UI shows new thread window immediately, with empty chat (loading)
POST to `/api/threads`
Create thread, node, optional document. Document is markdown, thread/node are JSON

**Send message**
Type message, all UI
Click send
POST to `/api/threads/{id}/messages`
Build the context for the message, using document + messages + nodes
Call OpenAI
Return new state of the thread: updated messages, updated nodes, updated Doc
UI updates the state with messages

**Switch threads**
If thread already cached, all UI. Otherwise GET `/api/threads/{id}`

**Save document**
`POST /api/docs/{id}`




Latest TODO
Currently migrating document handling to server-side. Need to decide if it's better for front end to
1. Send thread ID, message, and "is_edit"
2. Send thread ID, message, current document content
Probably best to just send is_edit. The backend has faster access to the document... and we shld probably "save" the temp document anyway every time we send a message request. so
- When user sends message, save the latest state of the doc (we can add version history in the future, and cache sometimes)
- Request only needs to supply: thread ID, user message, and is_edit
- If is_edit, then the document will be updated on backend (or maybe we send the doc content, so fewer api calls? I.e. otherwise we would need a second api call to reload the doc state from server)
- Response contains the updated doc content. It will be reflected in editor, but won't be saved until user clicks "save" or sends another chat message
- Need to track history of doc. And doc can have "content", "proposedRevision", and user can accept the edits. Separate from "saving" to avoid confusion
- In any case, we always want what the user sees in the editor to be what the agent is seeing/editing
- maybe get rid of "save" button. Auto-save